### JavaScript Best Practice Guide

##1. Размещайте ваш скрипт в конце страницы.

Помните, что главная цель – сделать загрузку страницы максимально быстрой для пользователя. При загрузке скрипта браузер не может продолжить (* начать выполнение кода), пока не загружен весь файл. Поэтому пользователь должен будет ждать дольше, чтобы заметить какой-либо прогресс (* если скрипт размещается не в конце файла).

##2. Объявляйте переменные снаружи от цикла For

Неудачный вариант

for(var i = 0; i < someArray.length; i++) {
    var container = document.getElementById('container');
    container.innerHtml += 'my number: ' + i;
    console.log(i);
 }

Более удачный вариант

var container = document.getElementById('container');
 for(var i = 0, len = someArray.length; i < len;  i++) {
    container.innerHtml += 'my number: ' + i;
    console.log(i);
 }

 ##3. Комментируйте свой код.
Поначалу может показаться, что в этом нет необходимости,  вам следует комментировать ваш код насколько это возможно. Что произойдет, когда вы вернетесь к вашему проекту через несколько месяцев, – только то, что вы поймете: не так-то просто вспомнить ход собственной мысли. Или что если одному из ваших коллег необходимо будет внести изменения в ваш код? Всегда, всегда комментируйте важные части вашего кода.

##4. Не передавайте строку в "SetInterval" или "SetTimeOut"
Рассмотрим следующий код:

setInterval(
 "document.getElementById('container').innerHTML += 'My new number: ' + i", 3000
 );
Этот код не только неэффективен, но и ведет себя таким же образом, как и вела бы себя функция "eval". Никогда не передавайте строку в "SetInterval" или "SetTimeOut". Вместо этого передавайте имя функции.

setInterval(someFunction, 3000);

##5. Используйте {} вместо New Object()
Имеется множество способов создания объектов в JavaScript. Вероятно, более традиционным способом является использование конструктора «new», например:

var o = new Object();
 o.name = 'Jeffrey';
 o.lastName = 'Way';
 o.someFunction = function() {
    console.log(this.name);
 }
Однако, этот способ зарекомендовал себя как «плохую практику» без должных на то оснований. Вместо этого я вам рекомендую использовать более надежный способ создания объектов – при помощи литерала (* литеральная (символьная) константа).

Более удачный вариант

var o = {
    name: 'Jeffrey',
    lastName = 'Way',
    someFunction : function() {
       console.log(this.name);
    }
 };
Обратите внимание, что если вы просто хотите создать пустой объект, использование {} решит проблему.

##6. Используйте [] вместо New Array()
То же справедливо и при создании нового массива.

Нормально

var a = new Array();
 a[0] = "Joe";
 a[1] = 'Plumber';
Более удачный вариант

var a = ['Joe','Plumber'];

##7. Всегда, всегда используйте точки с запятой (;)
Технически в большинстве браузеров опускание «;» сойдет вам с рук.

var someItem = 'some string'
 function doSomething() {
   return 'something'
 }
Тем не менее, это очень плохая практика, в результате использования которой потенциально могут возникнуть гораздо более крупные и тяжелые для обнаружения проблемы.

##8. Используйте === вместо ==

В JavaScript используются два вида операторов равенства: === | !== и == | != . Рекомендуется всегда использовать первый набор при сравнении (* предотвращает ошибки приведения типов.

##9.  Воспользуйтесь JS Lint

JSLint – отладочная программа, написанная Дугласом  Крокфордом (Douglas Crockford). Просто вставьте код вашего скрипта, и она проверит его на наличие очевидных проблем и ошибок.


##10. Функции должны делать что-то одно. Это одно из важнейших правил в программировании. Если функция выполняет более, чем одну вещь, то ee сложнее проверить и отладить. Если функция изолированна и делает что-то одно, ее проще отрефакторить.

Так делать не надо:

function notifyListeners(listeners) {
 listeners.forEach(listener => {
  const listenerRecord = database.lookup(listener);
  if (listenerRecord.isActive()) {
   notify(listener);
  }
 });
} 

А это хорошо:

function notifyActiveListeners(listeners) {
 listeners.filter(isListenerActive).forEach(notify);
}

function isListenerActive(listener) {
 const listenerRecord = database.lookup(listener);
 return listenerRecord.isActive();
}
